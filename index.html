<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Circuit Matrix</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <canvas id="matrixCanvas"></canvas>
        <canvas id="circuitCanvas"></canvas>
        <div class="intro">
            <h1> Kesiena Berezi</h1>
            
        </div>
        <div class="profile">
            <img src="images/headshot.jpg" alt="Kesiena Berezi">
        </div>
    </div>
   
    

    <script>
        // MATRIX CODE RAIN EFFECT WITH FLICKER
        const matrixCanvas = document.getElementById("matrixCanvas");
        const matrixCtx = matrixCanvas.getContext("2d");

        function resizeCanvas() {
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            fontSize = Math.max(12, Math.floor(matrixCanvas.width / 100)); // Adjust font size based on width
            columns = Math.floor(matrixCanvas.width / fontSize);
            drops = Array(columns).fill(1);
        }

        let fontSize;
        let columns;
        let drops;

        resizeCanvas();

        const chars = "0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ @#$%^&*()_+-=[]{}|;:<>?,./";
        const charArray = chars.split("");

        // Define message for the rain
        const message = "WELCOME TO MY PAGE";
        const messageArray = message.split("");
        let messageIndex = 0;

        function drawMatrix() {
            matrixCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
            matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

            // Slight flickering effect on text
            let flickerIntensity = Math.random() * 0.5 + 0.5; // Random opacity for flicker effect
            matrixCtx.fillStyle = `rgba(255, 0, 0, ${flickerIntensity})`; // Blood red text with flicker
            //make white
            matrixCtx.fillStyle = "white";

            matrixCtx.font = `${fontSize}px monospace`;

            for (let i = 0; i < drops.length; i++) {
                const text = messageArray[messageIndex];
                const x = i * fontSize;
                const y = drops[i] * fontSize;

                matrixCtx.fillText(text, x, y);

                if (y > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;

                messageIndex = (messageIndex + 1) % messageArray.length;
            }
        }

        setInterval(drawMatrix, 50);

        // CIRCUIT BOARD CONNECTIONS WITH GLOW & COLOR SHIFT
        const circuitCanvas = document.getElementById("circuitCanvas");
        const circuitCtx = circuitCanvas.getContext("2d");
        circuitCanvas.width = window.innerWidth;
        circuitCanvas.height = window.innerHeight;

        let paths = [];
        let hue = 0; // For shifting colors dynamically

        class Path {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.history = [{ x, y }];
                this.direction = Math.floor(Math.random() * 4);
            }

            update() {
                let step = 10;
                switch (this.direction) {
                    case 0: this.x += step; break;  // Right
                    case 1: this.x -= step; break;  // Left
                    case 2: this.y += step; break;  // Down
                    case 3: this.y -= step; break;  // Up
                }
                this.history.push({ x: this.x, y: this.y });

                if (Math.random() > 0.9) {
                    this.direction = Math.floor(Math.random() * 4);
                }
            }

            draw() {
                circuitCtx.beginPath();
                
                // Dynamic color shift effect
                let dynamicColor = `hsl(${hue}, 100%, 60%)`;
                circuitCtx.strokeStyle = dynamicColor;

                // Neon glow effect
                circuitCtx.lineWidth = 1;
                circuitCtx.shadowBlur = 10;
                circuitCtx.shadowColor = dynamicColor; 

                for (let i = 0; i < this.history.length - 1; i++) {
                    circuitCtx.moveTo(this.history[i].x, this.history[i].y);
                    circuitCtx.lineTo(this.history[i + 1].x, this.history[i + 1].y);
                }
                circuitCtx.stroke();
            }
        }

        function initPaths() {
            for (let i = 0; i < 10; i++) {
                paths.push(new Path(Math.random() * circuitCanvas.width, Math.random() * circuitCanvas.height));
            }
        }

        function animateCircuits() {
            circuitCtx.clearRect(0, 0, circuitCanvas.width, circuitCanvas.height);

            // Slowly shift colors from red to blue
            hue += 0.5;
            if (hue > 360) hue = 0;

            for (let path of paths) {
                path.update();
                path.draw();
            }

            requestAnimationFrame(animateCircuits);
        }

        initPaths();
        animateCircuits();

        window.addEventListener("resize", resizeCanvas);
    </script>
</body>
</html>
